-----------------------------------------------------------------------
|  CHAPTER 10 - EXCEPTION HANDLING                                    |
-----------------------------------------------------------------------

- Exception-Handling Fundamentals

    - A Java exception is an object that describes a run-time error that has occurred
        in a piece of code.  They can be generated by the run-time system or thrown
        explicitly from your code.


    - Here is the standard exception handling block:

        try {
            // Block of code to monitor for errors
        }
        catch (ExceptionType1 exOb) {
            // Handler for Type 1
        }
        catch (ExceptionType2 exOb) {
            // Handler for Type 2
        }
        finally {
            // Block to be executed after try block ends
        }



- Exception Types

    - All exception types are subclasses of the built-in type 'Throwable'.  This type
        has 2 subclasses, 'Exception' and 'Error'.  

                                     Throwable
                                       /   \
                                Exception  Error
                                     |
                         RuntimeException

     
    - The 'Exception' type is used for exceptional conditions that user programs should
        catch.  This is the class you will subtype to create custom exception types.

      The 'RuntimeException' class is a subtype of 'Exception'.  These execptions  are 
        automatically defined, and include things like division by zero and invalid array 
        indexing.


    - The 'Error' type defines exceptions that are not meant to be caught by user 
        programs.  They indicate errors having to do with the runtime environment, like
        stack overflows.



- Uncaught Exceptions

    - When an uncaught exception is caught, execution of the class is halted immediately.


    - Any exception not caught in user code will be processed by the default handler.
        The default handler displays a string describing the exception, prints a stack
        trace, and terminates the program



- Using Try and Catch

    - Here, we catch a division by zero error:

        class Exc {
            public static void main(String args[]) {
                int d, a;
    
                try {
                    d = 0;
                    a = 42 / d;
                    System.out.println("This will not be executed.");
                } 
                catch (ArithmeticException e) {
                    System.out.println("Division by zero.");
                }
    
                System.out.println("After catch statement.");
            }
        }


    - The goal of most well-constructed 'catch' statements should be to resolve the 
        exceptional condition and continue as if nothing happened.

            catch (ArithmeticException e) {
                System.out.println("Division by zero.");
                a = 0;
            }


    - If we pass an exception as an argument, it's 'toString()' method will be called,
        giving us a description of the exception.

            catch {
                System.out.println("Exception: " + e);
                a = 0;
            }



- Multiple catch Clauses

    - If you have multiple catch clauses, they will be inspected in order.

        class MultipleCatches {
            public static void main(String args[]) {
                try {
                    int a = 0;
                    int b = 42 / a;
                    int c[] = { 1 };
                    c[42] = 99;
                } 
                catch (ArithmeticException e) {
                    System.out.println("Division By Zero: " + e);
                } 
                catch (ArrayIndexOutOfBoundsException e) {
                    System.out.println("Array Index OOB: " + e);
                } 
            }
        }


    - Exception subclasses must come before any superclasses in the list:

        catch (ArithmeticException e) {
            System.out.println("Division by zero: " + e);
        } 
        catch (Exception e) {
            System.out.println("General exception: " + e);
        }

      Violating this rule will cause a compiler error.



- Nested try Statements

    - A try statement can be nested within the block of another try statement.  Every 
        time a try statement is entered, the context of that exception is pushed onto
        the stack.

        try {
            int a = args.length;
            int b = 42 / a;

            try {
                int c[] = { 1 };
                c[42] = 99;
            }
            catch (ArrayIndexOutOfBoundsException e) {
                System.out.println("Array index exception: " + e);
            }
        }

        catch (ArithmeticException e) {
            System.out.println("Divide by 0: " + e);
        }

      In this case, the first exception will be caught and execution will be halted.
        The nested try is never executed.



- The throw Statement

    - You can throw exceptions explicitly:

        throw ThrowableInstance;


    - Here is an example:

        static void demoproc() {
            try {
                throw new NullPointerException("demo");
            } 
            catch (NullPointerException e) {
                System.out.println("Caught inside demoproc.");
                throw e;
            }
        }



- The throws Statement

    - If a method is capable of causing an exception that it does not handle, it must
        specify this behavior so that callers of the method can guard themselves against
        that exception.

     
    - You do this by including a 'throws' clause in the method's declaration.  A 'throws'
        clause lists the type of exceptions a method might throw.  This is necessary for
        all exceptions except 'Error' and 'RuntimeException' descendants.


    - You must declare the exceptions or a compile time error will result.  Also, you must 
        handle it in the calling code or a compile time error will result.

        class ThrowsDemo {
            static void throwOne() throws IllegalAccessException {
                System.out.println("Inside throwOne.");
            }
        
            public static void main(String args[]) {
                try {
                    throwOne();
                }
                catch (IllegalAccessException e) {
                    System.out.println("Caught: " + e);
                }
            }
        }



- The finally Block

    - The 'finally' block will be executed after a try/catch block, whether or not an
        exception is thrown.  Even if the exception is not caught, the 'finally' block
        will still be executed.

        try {
            System.out.println("Inside try.");
        }
        finally {
            System.out.println("Inside finally.");
        }


        try {
            System.out.println("Inside try.");
        }
        catch (Exception e) {
            System.out.println("Caught: " + e);
        }
        finally {
            System.out.println("Inside finally.");
        }



- Java's Built-in Exceptions

    - Here are Java's built-in Unchecked RuntimeExceptions:

        Exception                          Meaning
        --------------------------------------------------------------------------
        ArithmeticException                Arithmetic error, such as divide-by-zero.

        ArrayIndexOutOfBoundsException     Array index is out-of-bounds.

        ArrayStoreException                Assignment to an array element of an incompatible type.

        ClassCastException                 Invalid cast.

        IllegalArgumentException           Illegal argument used to invoke a method.

        IllegalMonitorStateException       Illegal monitor operation, such as waiting on an unlocked 
                                             thread.

        IllegalStateException              Environment or application is in incorrect state.

        IllegalThreadStateException        Requested operation not compatible with the current thread state.

        IndexOutOfBoundsException          Some type of index is out-of-bounds.

        NegativeArraySizeException         Array created with a negative size.

        NullPointerException               Invalid use of a null reference.

        NumberFormatException              Invalid conversion of a string to a numeric format.

        SecurityException                  Attempt to violate security.

        StringIndexOutOfBounds             Attempt to index outside the bounds of a string.

        UnsupportedOperationException      An unsupported operation was encountered.



- Java Checked Exceptions

    - Here is a list of Java's Checked Exceptions:

        Exception                          Meaning
        --------------------------------------------------------------------------
        ClassNotFoundException             Class not found.

        CloneNotSupportedException         Attempt to clone an object that does not implement the 
                                             Cloneable interface.

        IllegalAccessException             Access to a class is denied.

        InstantiationException             Attempt to create an object of an abstract class or interface.

        InterruptedException               One thread has been interrupted by another thread.

        NoSuchFieldException               A requested field does not exist.

        NoSuchMethodException              A requested method does not exist.



- Creating Your Own Exceptions

    - Here are the methods that the Exception class inherits from Throwable:

        Throwable fillInStackTrace()
          // This method fills in the execution stack trace.

        Throwable getCause()
          // This method returns the cause of this throwable or null if the cause is nonexistent 
          //   or unknown.

        String getLocalizedMessage()
          // This method creates a localized description of this throwable.

        String getMessage()
          // This method returns the detail message string of this throwable.

        StackTraceElement[] getStackTrace()
          // This method provides programmatic access to the stack trace information printed by 
          //   printStackTrace().

        Throwable initCause(Throwable cause)
          // This method initializes the cause of this throwable to the specified value.

        void printStackTrace()
          // This method prints this throwable and its backtrace to the standard error stream.

        void printStackTrace(PrintStream s)
          // This method prints this throwable and its backtrace to the specified print stream.

        void printStackTrace(PrintWriter s)
          // This method prints this throwable and its backtrace to the specified print writer.

        void setStackTrace(StackTraceElement[] stackTrace)
          // This method sets the stack trace elements that will be returned by getStackTrace() 
          //   and printed by printStackTrace() and related methods.

        String toString()
          // This method returns a short description of this throwable.


    - There are 2 constructors for an exception:

        Exception()
        Exception(String msg)


    - Here is an example of a custom exception:

        class MyException extends Exception {
            private int detail;
        
            MyException(int a) {
                detail = a;
            }
        
            public String toString() {
                return "My Exception[" + detail + "]";
            }
        }