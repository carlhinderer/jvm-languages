-----------------------------------------------------------------------
|  CHAPTER 10 - EXCEPTION HANDLING                                    |
-----------------------------------------------------------------------

- Exception-Handling Fundamentals

    - A Java exception is an object that describes a run-time error that has occurred
        in a piece of code.  They can be generated by the run-time system or thrown
        explicitly from your code.


    - Here is the standard exception handling block:

        try {
            // Block of code to monitor for errors
        }
        catch (ExceptionType1 exOb) {
            // Handler for Type 1
        }
        catch (ExceptionType2 exOb) {
            // Handler for Type 2
        }
        finally {
            // Block to be executed after try block ends
        }



- Exception Types

    - All exception types are subclasses of the built-in type 'Throwable'.  This type
        has 2 subclasses, 'Exception' and 'Error'.  

                                     Throwable
                                       /   \
                                Exception  Error
                                     |
                         RuntimeException

     
    - The 'Exception' type is used for exceptional conditions that user programs should
        catch.  This is the class you will subtype to create custom exception types.

      The 'RuntimeException' class is a subtype of 'Exception'.  These execptions  are 
        automatically defined, and include things like division by zero and invalid array 
        indexing.


    - The 'Error' type defines exceptions that are not meant to be caught by user 
        programs.  They indicate errors having to do with the runtime environment, like
        stack overflows.



- Uncaught Exceptions

    - When an uncaught exception is caught, execution of the class is halted immediately.


    - Any exception not caught in user code will be processed by the default handler.
        The default handler displays a string describing the exception, prints a stack
        trace, and terminates the program



- Using Try and Catch

    - Here, we catch a division by zero error:

        class Exc {
            public static void main(String args[]) {
                int d, a;
    
                try {
                    d = 0;
                    a = 42 / d;
                    System.out.println("This will not be executed.");
                } 
                catch (ArithmeticException e) {
                    System.out.println("Division by zero.");
                }
    
                System.out.println("After catch statement.");
            }
        }


    - The goal of most well-constructed 'catch' statements should be to resolve the 
        exceptional condition and continue as if nothing happened.

            catch (ArithmeticException e) {
                System.out.println("Division by zero.");
                a = 0;
            }


    - If we pass an exception as an argument, it's 'toString()' method will be called,
        giving us a description of the exception.

            catch {
                System.out.println("Exception: " + e);
                a = 0;
            }



- Multiple catch Clauses

    - If you have multiple catch clauses, they will be inspected in order.

        class MultipleCatches {
            public static void main(String args[]) {
                try {
                    int a = 0;
                    int b = 42 / a;
                    int c[] = { 1 };
                    c[42] = 99;
                } 
                catch (ArithmeticException e) {
                    System.out.println("Division By Zero: " + e);
                } 
                catch (ArrayIndexOutOfBoundsException e) {
                    System.out.println("Array Index OOB: " + e);
                } 
            }
        }


    - Exception subclasses must come before any superclasses in the list:

        catch (ArithmeticException e) {
            System.out.println("Division by zero: " + e);
        } 
        catch (Exception e) {
            System.out.println("General exception: " + e);
        }

      Violating this rule will cause a compiler error.



- Nested try Statements

    - A try statement can be nested within the block of another try statement.  Every 
        time a try statement is entered, the context of that exception is pushed onto
        the stack.

        try {
            int a = args.length;
            int b = 42 / a;

            try {
                int c[] = { 1 };
                c[42] = 99;
            }
            catch (ArrayIndexOutOfBoundsException e) {
                System.out.println("Array index exception: " + e);
            }
        }

        catch (ArithmeticException e) {
            System.out.println("Divide by 0: " + e);
        }

      In this case, the first exception will be caught and execution will be halted.
        The nested try is never executed.



- The throw Statement

    - You can throw exceptions explicitly:

        throw ThrowableInstance;


    - Here is an example:

        static void demoproc() {
            try {
                throw new NullPointerException("demo");
            } 
            catch (NullPointerException e) {
                System.out.println("Caught inside demoproc.");
                throw e;
            }
        }



- The throws Statement

    - If a method is capable of causing an exception that it does not handle, it must
        specify this behavior so that callers of the method can guard themselves against
        that exception.

     
    - You do this by including a 'throws' clause in the method's declaration.  A 'throws'
        clause lists the type of exceptions a method might throw.  This is necessary for
        all exceptions except 'Error' and 'RuntimeException' descendants.


    - You must declare the exceptions or a compile time error will result.  Also, you must 
        handle it in the calling code or a compile time error will result.

        class ThrowsDemo {
            static void throwOne() throws IllegalAccessException {
                System.out.println("Inside throwOne.");
            }
        
            public static void main(String args[]) {
                try {
                    throwOne();
                }
                catch (IllegalAccessException e) {
                    System.out.println("Caught: " + e);
                }
            }
        }